[["index.html", "Elegant and informative maps with tmap Welcome How to contribute?", " Elegant and informative maps with tmap Martijn Tennekes, Jakub Nowosad 2021-02-23 Welcome This is the online home of Elegant and informative maps with tmap, a book on geospatial data visualization with the R-package tmap. This version of the book was built on GH Actions on 2021-02-23. How to contribute? "],["intro.html", "Chapter 1 Introduction 1.1 What is tmap? 1.2 Thematic maps", " Chapter 1 Introduction This book teaches how to make elegant and informative maps with the R-package tmap. A couple of real-world applications are used to illustrate the whole process from exploring raw spatial data to presenting insightful results. We can distinguish three aspects that are required to make good maps: Software skills Without knowing how to use software for making maps, it will obviously be challenging to make maps with the computer. Yes, back in the old days, people like Henry Drury Harness and Charles Joseph Minard used pen and paper to draw maps, but the computational speed, reproducibility, and interactivity of digital maps cannot be missed. Domain knowledge It is essential to know the background of the data. Where does the data come from? What do the data units represent? What do the variables mean? Since data visualization is all about conveying information, it is obviously important to have domain knowledge in order to make good data visualizations. Data visualization knowledge Someone with software skills and knowledge of a certain domain will be able to make maps of the data. However, these maps will not necessarily be good maps, since visualization of spatial data is trickier than most people think. There are a few underlying principles in data visualization that, when violated, will result in maps that are prone to misinterpretation of the data. The main focus on this book will be on software skills, since our aim is to create maps with tmap. Along the way, we will cover the most important data visualization methodology. Since whole books have been written about it already, we will keep this brief and pragmatic. Obviously, it is not possible to cover the remaining aspect, domain knowledge. However, the example datasets do not require much specific domain knowledge. 1.1 What is tmap? The short answer is that tmap is an R package for visualization spatial data. The slightly longer answer is that tmap allows users to explore, analyze, and present spatial data in a intuitive way. In this book, you will find the long answer. 1.2 Thematic maps "],["geodata.html", "Chapter 2 Spatial data in R 2.1 Introduction 2.2 Data models 2.3 Spatial data representations in R 2.4 Map projections (CRS)", " Chapter 2 Spatial data in R 2.1 Introduction Vector and raster data models are two basic models used to represent spatial data. These spatial data models are closely related to map making, with each model having its own pros and cons. This chapter stars by describing several popular spatial data models (section 2.2). Each data model is introduced, explained how it is built, and how it is stored using different file formats. Next, this chapter presents how these different data models are implemented in R (section 2.3). It includes showing how to read different spatial data formats, how to understand spatial R objects, and where to find more information about preprocessing spatial data. Finally, it focuses on the map projections (section 2.4). This section gives a background on why do we need map projections and how to translate spatial data from an ellipsoid into a flat surface or computer screen. It also explains basic terms and gives an overview of map projections. 2.2 Data models Traditionally, spatial data is described by two basic data models: vector data model aimed at (section 2.2.1) representing the world using points, lines, and polygons, and raster data model focused on representing surfaces (section 2.2.2). Additionally, now we have an abundance of available spatial data and a variety of ways to obtain it. It includes having many district variables and repeated measurements for the same area. Therefore, we also present the concept of spatial data cubes (section 2.2.3). 2.2.1 Vector data model The vector data model represent the world as a set of spatial geometries with non-spatial attributes (Figure 2.1). The role of geometry is to describe the location and shape of spatial objects. Attributes, on the other hand, are used to store the properties of the data. There are three basic types of geometries: points, lines, and polygons, all of them are made up of coordinates (left part of Figure 2.1). A point is represented by a pair of coordinates, usually described as X and Y, allowing for locating this point in some space. X and Y could be unitless, in degrees, or in some measure units, such as meters (extended discussion on coordinates and related topics is in section 2.4). Points can represent features on different spatial scales, from a GPS position, location of a bench in a park, to a city on a small scale map. They are also used to express abstract features, such as locations of map labels. Properties of points can be expressed on maps by different point sizes, colors, or shapes. A line extends the idea of a point. It consists of several points with coordinates (called vertices) that are arranged in some order. Consecutive points are connected by straight lines. Therefore, a straight spatial line consists of two points (two pairs of coordinates), while complex spatial lines could be created based on a large number of points. It gives the illusion that the line is curved. Lines are used to representing linear features, such as roads, rivers, boundaries, footpaths, etc. In this case, we can express line features’ attributes using either lines’ color or their widths. A polygon is again a set of ordered points (vertices) connected by straight lines. Its only difference from the line is that the first and the last point in a polygon has the same coordinates, and thus close the object. The polygon representation is used to represent shapes and locations of different objects, from a lake or a patch of vegetation, through a building or a city block, to some administrative units. Polygons also have one unique feature - they could have holes. A polygon hole represents an area inside of the polygon but does not belong to it. For example, a lake with an island can be depicted as a polygon with a hole. The values of polygons’ attributes can be represented by the areas (fill) colors. The second part of the vector data model relates to non-spatial attributes (right part of Figure 2.1). Attributes are usually stored as a table, in which each column depicts some property, such as an identification number, a name of a feature, or a value of some characteristic. Each row, on the other hand, relates to a single spatial geometry. FIGURE 2.1: Instances of spatial vector data model: POINTS, LINES, and POLYGONS. The above ideas could be implemented in many ways. Currently, the Simple Feature Access seems to be the most widely used standard. In it, a feature is every object or concept that have spatial location or extent. Simple feature standard makes a clear distinction between single- and multi-element features. We can have a POINT feature and a MULTIPOINT feature, and similarly LINESTRING and MULTILINESTRING, and POLYGON and MULTIPOLYGON. The main difference between single element features (such as POINT or POLYGON) and multi-element features (such as MULTIPOINT or MULTIPOLYGON) can be clearly seen by looking at attribute tables. For example, six points stored as POINT features fill six separate rows, while six points stored as just one MULTIPOINT feature occupy just one row. Examples of single- and multi-element features can be seen in Figure 2.1. The top example shows point data represented as MULTIPOINT feature: although we have seven points (seven distinct pairs of coordinates), they are gathered into two groups, green and orange, which can be seen in the associated attribute table. The central example, on the other hand, uses single-element features, where each line geometry relates to one row in the attribute table. Finally, the bottom example again uses multi-element features, where the second feature (Country B) consist of two separate geometries. The simple feature standard also describes a number of additional geometry types, including Curve, Surface, or Triangle. Finally, GeometryCollection exists that contains all of the possible geometry types. A couple hundreds of file formats exist to store spatial vector data. One of the simplest ways to store spatial data is in the form of a text file (.csv) or as a spreadsheet (.xls or .xlsx). While it makes storing point data simple, with two columns representing coordinates, it is not easy to store more complex objects in this way. Text files are also not suitable for storing information about the coordinate reference system used (section 2.4). Historically, the shapefile format (.shp) developed by the ESRI company gained a lot of interest and become the most widely supported spatial vector file format. Despite its popularity, this format has a number of shortcomings, including the need to store several files, attribute names limited to ten characters, the ability to store up to 255 attributes and files up to 2GB, and many more. A fairly recent file format, OGC GeoPackage (.gpkg), was developed as an alternative. It is a single file database free from the limitation of the shapefile format. Other popular spatial vector file formats include GeoJSON (.geojson), GPX (.gpx), and KML (.kml). 2.2.2 Raster data model The raster data model represents the world using a continuous grid of cells, where each cell has a single associated value (Figure 2.2). Depending on the type of values, we can distinguish continuous and categorical rasters. In continuous rasters, such as elevation or precipitation, values vary progressively. Categorical rasters, on the other hand, uses integer values to represent classes. Their examples include land cover or soil types maps. Raster data can also contain cells for which we do not know the value (Figure 2.2). For example, data for this part of the area was not collected, or these locations are outside of our area of interest. FIGURE 2.2: Basic representation of the raster data model: (1) Cell IDs, (2) Cell values, and (3) A raster map When we think about raster data, most of the time we are referring to regular grids (Figure 2.3). In regular grids, each cell has the same, constant size, and coordinates change from top to bottom and from left to right1. Regular rasters can be transformed into rotated and sheared rasters (Figure 2.3). Rotated grids are the result of transforming both coordinated, \\(x\\) and \\(y\\) using the same rotation coefficients. Sheared grids are created when the rotation coefficients are not equal. Rectilinear grids, on the other hand, have orthogonal axes, but consist of rectangular cells with different sizes and shapes (Figure 2.3). In the last type of raster data grids, curvilinear grids, cells are cuboids of different sizes and shapes (Figure 2.3). FIGURE 2.3: Main types of raster data grids: (1) Regular, (2) Rotated, (3) Sheared, (4) Rectilinear, and (5) Curvilinear Contrary to spatial vector data, a basic raster data stores just one attribute. It is, however, possible to stack together many single rasters (also known as raster layers). This allows us to store and operate on many rasters having the same dimensions at the same time. Examples of multi-layer rasters include satellite imageries or temporal rasters. Satellite imageries usually consist of many bands (layers) for different wavelengths. The most basic bands, representing the colors red, green, and blue, can be connected together to create one composite image with true colors (Figure 2.4). Temporal rasters store one attribute, but for many moments in time. Additional information about multi-layer rasters can be also found in Section 2.2.3. FIGURE 2.4: Example of three satellite imagery bands: red, green, blue, and the composite image with true colors created using these three bands. Similarly to vector data, a large number of raster file formats exists. Currently, the GeoTIFF format (.tif or .tiff) is one of the most popular spatial raster formats. It is an extended image TIF format that stores spatial metadata (e.g., map projection) along the values. Another popular spatial raster formats include Arc ASCII (.asc) and ERDAS Imagine (.img). 2.2.3 Spatial data cubes Traditionally, spatial vector and raster data models refer to a unique set of locations. For example, each feature in a polygon dataset and each cell in a raster dataset refer to one specific area. However, to solve real-life problems, we need to store and operate on more complex data structures. It includes situations when we have many attributes, often for several moments in time. Storing multiple attributes is not a problem for the vector data model, when an attribute table can have many columns. The question is how to extend the spatial vector data model to include measurements for many times. For example, let’s consider a polygon data with many attributes representing shares of land-use types for several years (Figure 2.5). One approach would be to create a separate column for each variable in each year. Alternatively, we can have one column representing the year and one column for each attribute, however, this approach would require multiplying each geometry as many times as we have time stamps. The third approach involves separating geometries from attributes, and where attributes for each moment are stored independently. The last idea is used in spatial vector data cubes (section 2.3.2). An example of the spatial vector data cubes idea can be seen in Figure 2.5. It consists of two elements: a geometry (MULTIPOLYGON) of provinces of the Netherlands and an array connected to it that stores shares of land-use types for several years. FIGURE 2.5: Vector data cube. A single raster dataset can store just one variable for a given area. To store several attributes, we can connect rasters representing different attributes for the same extent, creating multi-layer rasters (section 2.2.2). Additionally, each of the aforementioned rasters can be collected for many moments in time, adding other layers to the data. The question here is how to efficiently store multi-layer raster data to understand what layers relate to which attribute and time. Similarly to spatial vector data cubes, we can think of separating spatial dimensions from non-spatial attributes and create spatial raster data cubes (section 2.3.2). Figure 2.6 gives an example of a raster data cube. It consists of several single-layer rasters with the same spatial properties, such as resolution, extent, and CRS. These rasters are organized to store four-dimensions of the data: latitude, longitude, time, and attributes. It has values of three attributes for five moments in time in total. FIGURE 2.6: Raster data cube. Spatial data cubes are suitable for many real-life applications. For example, time-series of climate measurements for several stations, demographic data on a country level gathered for many years, or satellite imageries over some period of time. One way to create spatial data cubes is by connecting many independent vector or raster objects. Second way is to read a spatial data cube from one of the file formats allowing for storing complex data. It includes formats such as NetCDF (.nc) and HDF (.hdf). 2.3 Spatial data representations in R R has several packages aimed to represent spatial vector data. For more than a decade, the sp package was a standard of vector data representation in R. However, now this package is in the maintenance mode only, and its successor, sf is recommended. The tmap package has been using sf since version 2.0. Several R packages can be used to represent spatial raster data, including raster and its successor terra. The raster package was used as a backbone of raster data visualization until tmap version 3.0. Nowadays, the stars package is used by tmap to operate on raster data and spatial data cubes. In the two next sections, we introduce the sf package (2.3.1) and the stars package (section 2.3.2). 2.3.1 The sf package The sf package implements ideas behind the Simple Feature standard, which describe how to represent spatial vector data. Its main class, sf, has the form of an extended data frame, where each row is a spatial feature. In it, attributes of the vector data are stored as columns. It also has one additional column, most often named geom or geometry2. This column contains geometries in a form of well-known text (WKT), storing all of the coordinates. The sf package can read all of the spatial data formats mentioned in section 2.2.1 using the read_sf() function3. # replace this data with some new tmap dataset library(sf) file_path = system.file(&quot;shapes/world.gpkg&quot;, package = &quot;spData&quot;) x = read_sf(file_path) The new object, x, has a sf class. It has 177 features (rows or geometries) and 10 fields (columns with attributes). There is also an 11th column, geom, that stores geometries of each feature. Objects of class sf also display a header containing spatial metadata. It includes geometry type, dimension (XY, XYZ, XYM, XYZM), bounding box (bbox), and information about the used Coordinate Reference System (CRS). x #&gt; Simple feature collection with 177 features and 10 fields #&gt; geometry type: MULTIPOLYGON #&gt; dimension: XY #&gt; bbox: xmin: -180 ymin: -90 xmax: 180 ymax: 83.6 #&gt; geographic CRS: WGS 84 #&gt; # A tibble: 177 x 11 #&gt; iso_a2 name_long continent region_un subregion type #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 FJ Fiji Oceania Oceania Melanesia Sove… #&gt; 2 TZ Tanzania Africa Africa Eastern … Sove… #&gt; 3 EH Western S… Africa Africa Northern… Inde… #&gt; 4 CA Canada North Am… Americas Northern… Sove… #&gt; 5 US United St… North Am… Americas Northern… Coun… #&gt; 6 KZ Kazakhstan Asia Asia Central … Sove… #&gt; 7 UZ Uzbekistan Asia Asia Central … Sove… #&gt; 8 PG Papua New… Oceania Oceania Melanesia Sove… #&gt; 9 ID Indonesia Asia Asia South-Ea… Sove… #&gt; 10 AR Argentina South Am… Americas South Am… Sove… #&gt; # … with 167 more rows, and 5 more variables: #&gt; # area_km2 &lt;dbl&gt;, pop &lt;dbl&gt;, lifeExp &lt;dbl&gt;, #&gt; # gdpPercap &lt;dbl&gt;, geom &lt;MULTIPOLYGON [°]&gt; The x object has MULTIPOLYGON geometry type, where each feature (row) can consist of one or more polygons. Each polygon’s vertices are represented by a pair of values (dimension: XY). Bounding box allows to quickly understand the spatial extension of the input data. Finally, it has geographic CRS named WGS 84. You can learn more about Coordinate Reference Systems in section 2.4. Spatial vector data of class sf can be also obtained using some of other R data packages. For example, rnaturalearth allows to download world map data, osmdata imports OpenStreetMap data as sf objects, and tigris loads TIGER/Line data. The tmap package accepts spatial vector data objects from both sf and sp packages. In case of having vector objects in a different representation, they should be converted into sf objects first, before making maps. The sf package has the st_as_sf() function that translates objects of many classes, including Spatial (from the sp package), ppp, psp, and lpp (from the spatstat package), to the objects of class sf. The st_as_sf() function also allows to turn data frames into sf objects - the user needs to provide the input data frame, names of columns with coordinates, and additionally definition of the CRS of the data. For example my_sf = st_as_sf(my_df, coords = c(\"Xcolumn\", \"Ycolumn\"), crs = 4326). If you want to learn more about operating on sf objects, we recommend visiting the package website and vignettes at https://r-spatial.github.io/sf/index.html and reading the Geocomputation with R book (Lovelace, Nowosad, and Muenchow 2019). 2.3.2 The stars package The stars package allows for reading and processing raster data in R. This package also has support for both spatial vector and raster data cubes. Its main class, stars, is built as a list of matrices or arrays with metadata describing their dimensions. The stars package is also well integrated with sf, with many st_ functions (such as st_crs()) working also on stars objects. The read_stars() function allow to read spatial raster data from a file4. This function requires at least one argument with a filename to be read. library(stars) file_path2 = system.file(&quot;raster/srtm.tif&quot;, package = &quot;spDataLarge&quot;) x2 = read_stars(file_path2) The new object, x2, is of a stars class. It has two dimensions, x and y, and one attribute srtm.tif. x2 #&gt; stars object with 2 dimensions and 1 attribute #&gt; attribute(s): #&gt; srtm.tif #&gt; Min. :1024 #&gt; 1st Qu.:1535 #&gt; Median :1837 #&gt; Mean :1843 #&gt; 3rd Qu.:2114 #&gt; Max. :2892 #&gt; dimension(s): #&gt; from to offset delta refsys point values x/y #&gt; x 1 465 -113.24 0.000833333 WGS 84 FALSE NULL [x] #&gt; y 1 457 37.5129 -0.000833333 WGS 84 FALSE NULL [y] The srtm.tif attribute is a matrix, where each cell represents an elevation value. The x dimension has 465 elements (columns), starting from a coordinate (offset) of a cell boundary of -113.24. Next, the coordinates of further cells increase by 0.000833333 (delta) - resolution in the x dimension. The y dimension has 457 elements (rows), starting from a coordinate (offset) of a cell boundary of 37.5129. For the y dimension, each further cell’s coordinated decreases by 0.000833333 (notice the negative value of delta) - resolution in the y dimension. Both dimensions also have the same CRS - WGS 84. read_stars() also has several additional arguments including RasterIO, which gives control over the input data extent and resolution. For example, the below code will read just the first and second bands (results not shown). file_path3 = system.file(&quot;raster/landsat.tif&quot;, package = &quot;spDataLarge&quot;) x3 = read_stars(file_path3, RasterIO = list(bands = c(1, 2))) Internally, a stars object is a list of matrix or array objects with additional attributes describing spatial metadata, such as a number of columns and rows, resolution, coordinate reference system, etc. All of this information is read from the input file. Stars objects are constructed by dimensions and attributes. Dimensions relate to what kind of objects are stored as list elements. For example, when it is a matrix then we just have two dimensions representing columns and rows. However, it is also possible to store multidimensional arrays, which allow having many additional dimensions for bands, times, etc. Attributes, on the other hand, are stored as list elements. Each attribute can relate, for example to a different variable. Reading a simple GeoTIFF file would result in having just two dimensions and one attribute (a matrix). On the other hand, reading complex raster file formats, such as NetCDF could result in having more than two dimensions (e.g. time) and many attributes (e.g., an array with temperature, precipitation, humidity). Before reading the file, the stars package checks if the input data is a curvilinear grid and what is the number of cells in the data. When the input data is small or curvilinear then the full data is read in computer memory. Otherwise, a stars proxy approach is used, where only metadata is read including pointers to where the complete data is. When we want to plot large raster data, then it is read at a lower resolution than the native one. The stars package also has support for vector data cubes, where each geometry is just stored once (as a dimension), and each attribute is a matrix or an array with the number of rows equals to the number of geometries, the number of columns equals to another dimension (e.g., time), and possibly the number of array layers equals for additional dimensions. More information on how the stars objects are organized and how to operate on them can be found in the stars package vignettes at https://r-spatial.github.io/stars. 2.4 Map projections (CRS) 2.4.1 What are map projections? We use maps so often in everyday life that most of us probably forget that a map is just a two-dimensional representation of a three-dimensional object, namely the earth. For centuries, geographers and mathematicians wondered what the best way is to do this. Let us wonder with them for a second. The world is shown as an orange below, not just to stimulate your appetite for this subject, but also since an orange peel is a good analogy for a two-dimensional map. A world map can be seen as an orange peel that is put flat on the table. The question is how to do this. FIGURE 2.7: How to peel an orange? When we peel the orange, ideally we want to rip the peel near areas of the earth that are less interesting. What is interesting depends on the application; for applications where land mass is more important than wetlands, it is a good idea to make the rips in the oceans. The (interrupted) Goode homolosine projection, which is shown below, embodies this idea. All continents and countries are preserved, except Antarctica and Greenland. There is also a version of the Goode homolosine projection that focuses on preserving the oceans. FIGURE 2.8: The (interrupted) Goode homolosine projection To make the analogy between the orange peel and the surface of the earth complete, we have to assign two fictitious properties to the orange peel, namely that it is stretchable and deformable. These properties are needed in order to make a non-interrupted map, as we will see in the next sections. A method to flatten down the earth, for which the Goode homolosine projection shown Figure 2.8 is an example, is called a map projection. Technically, it is also known as a coordinate reference system (CRS), which specifies the corresponding coordinate system, as well as the transformations to other map projections. 2.4.2 A model of the Earth The orange and the Earth have another thing in common; both are spheres, but not perfect ones. The Earth is metaphorically speaking a little fat: the circumference around the equator is 40,075 km whereas around the circumference that crosses both poles is 40,009 km. Therefore, the earth can better be described as an ellipsoid. The same applies to an orange; every orange is a little different, but probably very few oranges are perfect spheres. Although the ellipsoid is a good mathematical model to describe the earth’s surface, keep in mind that the surface of the earth is not smooth; land mass usually lies on a higher altitude than sea level. We could potentially map each point on the surface of the earth using a three-dimensional \\((x, y, z)\\) Cartesian coordinate system with the center of the mass of the Earth being the origin (0, 0, 0). However, since this has many mathematical complications, the ellipsoid is often sufficient as a model of the surface of the earth. This ellipsoid model and its translation to the Earth’ surface is called a (geodetic) datum. The most popular datum is WGS84, which has been introduced in 1984 as an international standard, and has been last revised in 2004. There are many (slightly) different datums, which are often tailored for local applications. For instance, NAD83, ETRS89, and GDA94 are slightly better models for North-America, Europe, and Australia respectively. However, since WGS84 is a very good approximation of the earth as a whole, it has been widely adopted worldwide and is also used by the Global Positioning System (GPS). When we have specified a datum, we are able to specify geographic locations with two familiar variables, namely latitude and longitude. The latitude specifies the north-south position in degrees, where latitude = 0\\(^\\circ\\) is the equator. The latitudes for the north and south pole are 90\\(^\\circ\\) and \\(-90^\\circ\\) respectively. The longitude specifies the east-west position in degrees, where by convention, the longitude = 0\\(^\\circ\\) meridian crosses the Royal Observatory in Greenwich, UK. The Longitude range is -180\\(^\\circ\\) to 180\\(^\\circ\\), and since this is a full circle, -180\\(^\\circ\\) and \\(^\\circ\\) specify the same longitude. When we see the earth in its three-dimensional form, as in Figure 2.7, the latitude parallels are the horizontal lines around the earth, and the longitude meridians are the vertical lines around the earth. The set of longitude meridians and latitude parallels is also referred to as graticule. In all the figures in this section, latitude parallels are shown as gray lines for \\(-60^\\circ\\), \\(-30^\\circ\\), \\(0^\\circ\\), \\(30^\\circ\\) and \\(60^\\circ\\), and longitude meridians from \\(-180^\\circ\\) to \\(180^\\circ\\) at every \\(30^\\circ\\). Please keep in mind that only a latitude and longitude are not sufficient to specify a geographic location. A datum is required. When people exchange latitude-longitude data, it is safe to assume that they implicitly have used the WGS84 datum. However, it is good practice to specify the datum explicitly. 2.4.3 Platte Carrée and Web Mercator Let’s take a closer look at two widely used map projections, namely the plain latitude-longitude coordinate system (using the WGS84 datum) and the Web Mercator projection, which is currently the de facto standard for interactive maps. These projections are indexed as EPSG4326 and EPSG3857 respectively. EPSG is an institute that maintains a database of standard map projections. FIGURE 2.9: The WGS84 coordinate system (EPSG4326) When we fictitiously make little holes in the orange peel at both poles, and stretch these open so wide that they have the same width as the equator, we obtain the cylinder depicted in Figure 2.9 (left). Note that the longitude lines have become straight vertical lines. When we unroll this cylinder, we obtain a map where the \\(x\\) and \\(y\\) coordinates are the longitude and latitude respectively. This CRS, which is known as EPSG4326, is shown in Figure 2.9 (right). EPSG4326 is an unprojected CRS, since the longitude and latitude have not been transformed. With projected CRSs, the \\(x\\) and \\(y\\) coordinates refer to specific measurement units, usually meters. The projected variant of this CRS is called the Platte Carrée (EPSG4087), and is exactly the same map as shown in Figure 2.9 (right), but with other \\(x\\) and \\(y\\) value ranges. Observe since we stretched the poles open, the area near the poles have been stretched out as well. More specifically, the closer the land is to one of the poles, the more it has been stretched out. Since the stretching direction is only horizontally, the shapes of the areas have become wider. A good example is Greenland, which is normally a ‘tall’ area (as can be seen in Figure 2.7). In order to fix these deformed areas, Gerardus Mercator, a Flemish geographer in the 16th century introduced a method to compensate for this by inflating the areas near the poles even more, but now only in a vertical direction. This projection is called the Mercator projection. For web applications, this projection has been slightly modified and renamed to the Web Mercator projection (EPSG3857). The cylinder and plain map that uses this projection are shown in Figure 2.10. FIGURE 2.10: Web Mercator projection (EPSG3857) Although the areas near the poles have been inflated quite a lot, especially Antarctica and Greenland, the shape of the areas is more or less correct, in particular regarding small areas (which can be seen by comparing with Figure 2.7). The Mercator projection is very useful for navigational purposes, and has therefore been embraced by sailors ever since. Also today, the Web Mercator is the de facto standard for interactive maps and navigation services. However, for maps that show data the (Web) Mercator projection should be used with great caution, because the hugely inflated areas will influence how we perceive spatial data. We will discuss this in the next section. 2.4.4 Types of map projections Let us go back to the original question: how can we make a two-dimensional image of our three-dimensional earth? Although there are many ways, four basic map projection types can be distinguished. These are depicted in Figure 2.11. FIGURE 2.11: Four types of map projections Examples for cylindrical projections have already been given in the previous section; both Platte Carrée and Web-Mercator are cylindrical. Another widely used cylindrical map projection is the Universal Transverse Mercator (UTM). The cylinder is not placed upright, but horizontal. There are 60 positions in which this cylinder can be placed, where in each position, the cylinder faces a longitude range of 6 degrees. In other words the UTM is not a single projection, but a series of 60 projections. There are many projections which are pseudo-cylinders in the sense that the radius around the poles is smaller than around the equator. An example is the Robinson projection shown in Figure 2.12. Almost all commonly used standard World map projections are (pseudo-)cylindrical. FIGURE 2.12: The Robinson projection, which is pseudo-cylindrical. An example of a conic map projection is shown in 2.13(a). As a result of unfolding a cone on a flat surface, a gap is created. The size (angle) of this gap depends on the width of the cone. There are also pseudo-conic map projections in which some meridians (longitude lines) are curved. Conic map projections are useful for mid-latitude areas where the surfaces of the earth and the cone are almost parallel to each other. Planar map projections, also known as azimuthal projections, project the Earth on a disk. This can be done in several ways. This can best be explained by the position of an imaginary light source. It can be placed inside the globe, at the surface of the globe opposite to the disk, and at an infinite distance opposite to the disk. The corresponding families of projections are called gnomonic, stereographic, and orthogonal projections. Planar map projections are often used for a specific country or continent. An example is the Lambert Azimuthal Equal-Area projection (EPSG3035), shown in 2.13(b), which is optimized for Europe. It can be classified as a stereographic projection, although the light beams are not straight but curved. Another example of a planar map projection is the orange shown in Figure 2.7. This is an orthogonal projection. FIGURE 2.13: Examples of a conic (a) and a planar (b) projection. The (interrupted) Goode homolosine projection shown in Figure 2.8 is an example of an interrupted projection. A special class of these projections are polyhedral projections, which consists of planar faces. In Figure 2.11 a polyhedral of six faces is illustrated. There is no limit of the number of faces, as the myriahedral projections (TODO reference Van Wijck paper) illustrate. 2.4.5 Which projection to choose? Hopefully it is clear that there is no perfect projection, since each projection has its pros and cons. Whether a projection is good for a certain application, depends on two factors. The first factor is the type of application and in particular which map projection properties are useful or even required for that application. For instance, navigation requires other map projection properties than statistical maps. The second factor is the area of interest. Is the whole World visualized or only a part, and in the latter case, which part? In this section, guidelines are provided to choose a proper projection based on those two aspects. Before we go deeper into selecting a projection, it is worth noting that for many countries and continents, government agencies already have chosen projections to be the standard for mapping spatial data. For instance, a standard for Europe, which is used by Eurostat (the statistical agency of the European Union), is the Lambert Azimuthal Equal-Area projection shown in Figure 2.13(b). If the area of interest has such a standard, it is recommended to use it, because it can be safely assumed that this standard is a proper projection, and moreover, it makes cooperation and communication with other parties easier. However, be aware of the limitations that this particular projection may have, and that there may be better alternatives out there. Map projection properties The type of application is important for the choice of a map projection. However, it would be quite tedious to list all possible applications and provide projection recommendations for each of them. Instead, we focus on four map projection properties. The key step is to find out which of these properties are useful or even required for the target application. The four properties are listed in the following table. TABLE 2.1: Map projection properties. Property Conformal Equal area Equidistant Azimuthal Preserves Local angle (shape) Area Distance Direction Applications Navigation, climate Statistics Geology Geology Examples (cyclindrical) Mercator Gall-Peters, Eckert IV Equirectangular none Examples (conic) Lambert conformal conic Albers conic Equidistant conic none Examples (planar) Stereographic Lambert azimuthal equal-area Azimuthal equidistant Stereographic, Lambert azimuthal equal-area Examples (interrupted) Myriahedral Goode homolosine, Myriahedral none none A conformal projection means that local angles are preserved. In practice, that means that for instance a map of a crossroad preserves the angles between the roads. Therefore, this property is required for navigational purposes. As a consequence that local angles are preserved, local shapes are also preserved. That means that an small island will be drawn on a map in its true shape, as seen from the sky perpendicular above it. The Web Mercator shown in Figure 2.10 satisfies this property; the closer an area is to one of the poles, the more it is enlarged, but since this is done in both dimensions (latitude and longitude), local shapes are preserved. A map projection is called equal-area if the areas are proportional to the true areas. This is strongly recommended for maps that show statistics in order to prevent perceptual bias. Figure 2.14 shows two World maps of population density per country, one in the Web Mercator projection and the other in Eckert IV projection. The perception of World population is different in these maps; in (a) the vast lands on low-populated areas seem to be Canada, Greenland, and Russia, whereas in (b) also North Africa and Australia emerge as vast low-populated areas. FIGURE 2.14: The Robinson projection, which is pseudo-cylindrical. The other two map projection properties are related to one central point on the map. A map projection is called equidistant if the distances to any other point in the map are preserved, and azimuthal if the directions to any other point are preserved. These properties are in particular useful in the field of geology. One example is a seismic map around the epicenter of a recent earthquake, where it is important to how far and in which direction the vibrations are spreading. A map projection can satisfy at most two of these properties. Many map projection do not satisfy any property but are intended as a compromise. An example is the Robinson projection, shown in Figure 2.12. Area of interest The next aspect that is important for the choice of a map projection is the area of interest. In general, the larger the area, the more concessions have to be made, since the larger the area, the more difficult it is to make a two-dimensional projection. The following table provides recommendations of map projection types based on the area size and on the latitude of the area. TABLE 2.2: Recommended projections. View Low latitude (equator) Mid latitude High latitude (poles) World Pseudo-cylindrical Pseudo-cylindrical Pseudo-cylindrical Hemisphere Azimuthal Azimuthal Azimuthal Continent or smaller Cylindrical or azimuthal Conic or azimuthal Azimuthal For World maps, pseudo-cylindrical map projections, such as the Robinson projection (Figure 2.12) and the Eckert IV projection (Figure 2.14(b)) are very popular because they have less distortion other map projections. For areas that cover a half of the sphere, i.e. a hemisphere, azimuthal map projections are recommended. There are four hemispheres that are often used: the Northern and Southern Hemisphere, with respectively the North and South Pole as center, the Western Hemisphere consisting of the Americas, and the Eastern Hemisphere, which includes the other continents. However, other hemispheres are often used implicitly, such as a hemisphere centered on Europe used in the Lambert Azimuthal Equal-Area projection shown in Figure 2.13(b). For areas with the size of a continent or country, the azimuthal map projection type can be used when centered on the area of interest. In particular, the Lambert Azimuthal Equal-Area projection when equal area is required, and the Azimuthal Equidistant projection when preserving distances is important. Alternatively, cylindrical and conic map projection types can be used for areas at low and mid latitudes respectively. Another alternative is to use a UTM projection. However, this is only recommended when the target area spans less than 6 degrees longitude. 2.4.6 CRS in R Coordinate Reference Systems (CRSs) are implemented in the software library PROJ. With implementation, we mean specifying a CRS and transforming coordinates from one CRS to another. PROJ is used by every popular software application for spatial data, in particular ArcGIS, QGIS, and GRASS, and also by many programming languages, including R. The sf package integrates the PROJ functions into R. A CRS is represented in R by an object of class crs, which can be retrieved or set with the function st_crs (from the sf package). In the following example, a crs object is created from an EPSG code, in this case 3035, the Lambert Azimuthal Equal-Area projection for Europe. library(sf) # CRS Lambert Azimuthal Equal-Area projection st_crs(3035) #&gt; Coordinate Reference System: #&gt; User input: EPSG:3035 #&gt; wkt: #&gt; PROJCRS[&quot;ETRS89-extended / LAEA Europe&quot;, #&gt; BASEGEOGCRS[&quot;ETRS89&quot;, #&gt; DATUM[&quot;European Terrestrial Reference System 1989&quot;, #&gt; ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, #&gt; LENGTHUNIT[&quot;metre&quot;,1]]], #&gt; PRIMEM[&quot;Greenwich&quot;,0, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; ID[&quot;EPSG&quot;,4258]], #&gt; CONVERSION[&quot;Europe Equal Area 2001&quot;, #&gt; METHOD[&quot;Lambert Azimuthal Equal Area&quot;, #&gt; ID[&quot;EPSG&quot;,9820]], #&gt; PARAMETER[&quot;Latitude of natural origin&quot;,52, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], #&gt; ID[&quot;EPSG&quot;,8801]], #&gt; PARAMETER[&quot;Longitude of natural origin&quot;,10, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], #&gt; ID[&quot;EPSG&quot;,8802]], #&gt; PARAMETER[&quot;False easting&quot;,4321000, #&gt; LENGTHUNIT[&quot;metre&quot;,1], #&gt; ID[&quot;EPSG&quot;,8806]], #&gt; PARAMETER[&quot;False northing&quot;,3210000, #&gt; LENGTHUNIT[&quot;metre&quot;,1], #&gt; ID[&quot;EPSG&quot;,8807]]], #&gt; CS[Cartesian,2], #&gt; AXIS[&quot;northing (Y)&quot;,north, #&gt; ORDER[1], #&gt; LENGTHUNIT[&quot;metre&quot;,1]], #&gt; AXIS[&quot;easting (X)&quot;,east, #&gt; ORDER[2], #&gt; LENGTHUNIT[&quot;metre&quot;,1]], #&gt; USAGE[ #&gt; SCOPE[&quot;unknown&quot;], #&gt; AREA[&quot;Europe - LCC &amp; LAEA&quot;], #&gt; BBOX[24.6,-35.58,84.17,44.83]], #&gt; ID[&quot;EPSG&quot;,3035]] A crs object is represented by Well Known Text (WKT). It includes a specification of the used datum as well as information how to transform it into other CRSs. Understanding the exact content of the WTK is not important for most users, since it is not needed to write a WKT yourself. A crs object can be created in three ways: The first is with an EPSG number as user input specification as shown above. The second is also with a user input specification, but with a so-called proj4 character string. The proj4 character string for the LAEA projection is \"+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs\". However, proj4 character strings should be used with caution since they often lack important CRS information regarding datums and CRS transformations. Also note that the name proj4 stands for the PROJ library version 4, while the current major version of PROJ at the time of writing is already 7. The third way to create a crs object is to extract it from an existing spatial data object (e.g. an sf or stars object). A crs object can be used to define a new spatial object or to transform an existing spatial object into another projection. # create a data.frame of three famous waterfalls waterfalls = data.frame(name = c(&quot;Iguazu Falls&quot;, &quot;Niagara Falls&quot;, &quot;Victoria Falls&quot;), lat = c(-25.686785, 43.092461, -17.931805), lon = c(-54.444981, -79.047150, 25.825558)) # create sf object (without specifying the crs) waterfalls_sf = st_as_sf(waterfalls, coords = c(&quot;lon&quot;, &quot;lat&quot;)) # extract crs (not defined yet) st_crs(waterfalls_sf) #&gt; Coordinate Reference System: NA # specify crs st_crs(waterfalls_sf) = 4326 # extract crs st_crs(waterfalls_sf) #&gt; Coordinate Reference System: #&gt; User input: EPSG:4326 #&gt; wkt: #&gt; GEOGCRS[&quot;WGS 84&quot;, #&gt; DATUM[&quot;World Geodetic System 1984&quot;, #&gt; ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, #&gt; LENGTHUNIT[&quot;metre&quot;,1]]], #&gt; PRIMEM[&quot;Greenwich&quot;,0, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; CS[ellipsoidal,2], #&gt; AXIS[&quot;geodetic latitude (Lat)&quot;,north, #&gt; ORDER[1], #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; AXIS[&quot;geodetic longitude (Lon)&quot;,east, #&gt; ORDER[2], #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; USAGE[ #&gt; SCOPE[&quot;unknown&quot;], #&gt; AREA[&quot;World&quot;], #&gt; BBOX[-90,-180,90,180]], #&gt; ID[&quot;EPSG&quot;,4326]] # alternatively, create sf object with specifying the crs waterfalls_sf = st_as_sf(waterfalls, coords = c(&quot;lon&quot;, &quot;lat&quot;), crs = 4326) # transform to the Equal Earth projection (EPSG 8857) waterfalls_sf_trans = st_transform(waterfalls_sf, 8857) waterfalls_sf_trans #&gt; Simple feature collection with 3 features and 1 field #&gt; geometry type: POINT #&gt; dimension: XY #&gt; bbox: xmin: -6580000 ymin: -3240000 xmax: 2420000 ymax: 5260000 #&gt; projected CRS: WGS 84 / Equal Earth Greenwich #&gt; name geometry #&gt; 1 Iguazu Falls POINT (-4969711 -3244138) #&gt; 2 Niagara Falls POINT (-6583123 5261565) #&gt; 3 Victoria Falls POINT (2416945 -2285044) References "],["nutshell.html", "Chapter 3 tmap in a nutshell 3.1 Regular maps 3.2 Quick maps 3.3 Map modes", " Chapter 3 tmap in a nutshell 3.1 Regular maps 3.2 Quick maps 3.3 Map modes "],["tmshape.html", "Chapter 4 Specifying spatial data 4.1 Shapes and layers 4.2 Shapes hierarchy 4.3 Map projection 4.4 Map extent 4.5 Data simplification", " Chapter 4 Specifying spatial data In order to plot spatial data, at least two aspects need to be specified: the spatial data object itself, and the plotting method(s). We will cover the former in this chapter. The latter will be discussed in the next chapter. 4.1 Shapes and layers As described in Chapter 2, shape objects can be vector or raster data. We recommend sf objects for vector data and stars objects for raster data5. In tmap, a shape object needs to be defined with the function tm_shape(). When multiple shape objects are used, each has to be defined in a separate tm_shape() call. This is illustrated in the following example (Figure 4.1). tm_shape(land) + tm_raster(&quot;elevation&quot;, palette = terrain.colors(8)) + tm_shape(World) + tm_borders() + tm_shape(metro_large) + tm_dots() + tm_text(&quot;name&quot;) FIGURE 4.1: A map representing three shapes (land, World, and metro_large) using four layers. In this example, we use three shapes: land which is a stars object that contains an attribute called \"elevation\", World which is an sf object with country borders, and metro_large, which is an sf object that contains metropolitan areas of at least 20 million inhabitants. Each tm_shape() function call is succeeded by one or more layer functions. In the example these are tm_raster(), tm_borders(), tm_dots() and tm_text(). We will describe layer functions in detail in the next chapter. For this chapter, it is sufficient to know that each layer function call defines how the spatial data specified with tm_shape() is plotted. Shape objects can be used to plot multiple layers. In the example, shape metro_large is used for two layers, tm_dots() and tm_text(). We recommend to indent the code for the layer functions, in order to see which layers use which shape objects. 4.2 Shapes hierarchy The order of the tm_shape() functions’ calls is crucial. The first tm_shape(), known as the main shape, is not only shown below the following shapes, but also sets the projection and extent of the whole map. In Figure 4.1, the land object was used as the first shape, and thus the whole map has the projection and extent of this object. However, we can quickly change the main shape with the is.master argument. In the following example, we set the metro_large object as the main shape, which limits the output map to the point locations in metro_large (Figure 4.2)6. tm_shape(land) + tm_raster(&quot;elevation&quot;, palette = terrain.colors(8)) + tm_shape(World) + tm_borders() + tm_shape(metro_large, is.master = TRUE) + tm_dots() + tm_text(&quot;name&quot;) FIGURE 4.2: A map representing three shapes (land, World, and metro_large) using four layers. 4.3 Map projection As we mentioned in the previous section, the created map uses the projection from the main shape. However, we often want to create a map with a different projection to preserve specific property (Chapter 2.4). We can do this in two ways. The first way to use a different projection on a map is to reproject the main data before plotting, as shown in Section 2.4.6. The second way is to specify the map projection using the projection argument of tm_shape(). This argument expects either some crs object or a CRS code. In the next example, we set projection to 8857. This number represents EPSG 8857 of a projection called Equal Earth (Šavrič, Patterson, and Jenny 2019). The Equal Earth projection is an equal-area pseudocylindrical projection for world maps similar to the non-equal-area Robinson projection (Figure 2.12). Reprojections of vector data is usually straightforward because each spatial coordinate is reprojected individually. However, reprojecting of raster data is more complex and requires using one of two approaches. The first approach (raster.warp = TRUE) applies raster warping, which is a name for two separate spatial operations: creation of a new regular raster object and computation of new pixel values through resampling (for more details read Chapter 6 of Lovelace, Nowosad, and Muenchow (2019)). This is the default option in tmap, however, it has some limitations. Figure 4.3:A shows the world elevation raster reprojected to Equal Earth. Some of you can quickly noticed that certain areas, such as parts of Antarctica, New Zealand, Alaska, and the Kamchatka Peninsula, are presented twice: with one version being largely distorted. Another limitation of raster.warp = TRUE is the use of the nearest neighbor resampling only - while it can be a proper method to use for categorical rasters, it can have some unintended consequences for continuous rasters (such as the \"elevation\" data). tm_shape(land, projection = 8857) + tm_raster(&quot;elevation&quot;, palette = terrain.colors(8)) The second approach (raster.warp = FALSE) computes new coordinates for each raster cell keeping all of the original values and results in a curvilinear grid. This calculation could deform the shapes of original grid cells, and usually curvilinear grids take a longer time to plot7. Figure 4.3:B shows an example of the second approach, which gave a better result in this case without any spurious lands. However, creation of the B map takes about ten times longer than the A map. tm_shape(land, projection = 8857, raster.warp = FALSE) + tm_raster(&quot;elevation&quot;, palette = terrain.colors(8)) FIGURE 4.3: Two elevation maps in the Equal Earth projection: (A) created using raster.warp = TRUE, (B) created using raster.warp = FALSE. 4.4 Map extent Another important aspect of mapping, besides projection, is its extent - a portion of the area shown in a map. This is not an issue when the extent of our spatial data is the same as we want to show on a map. However, what should we do when the spatial data contains a larger region than we want to present? Again, we could take two routes. The first one is to preprocess our data before mapping - this can be done with vector clipping (e.g., st_intersection()) and raster cropping (e.g., st_crop()). We would recommend this approach if you plan to work on the smaller data in the other parts of the project. The second route is to specify the map extent in tmap. tmap allows specifying map extent using three approaches. The first one is to specify minimum and maximum coordinates in the x and y directions that we want to represent. This can be done with a numeric vector of four values in the order of minimum x, minimum y, maximum x, and maximum y, where all of the coordinates need to be specified in the input data units^[This can also be done with the object of class st_bbox or a 2 by 2 matrix. In the following example, we limit our map extent to the rectangular area between x from -15 to 45 and y from 35 to 65 (Figure 4.4). tm_shape(land, bbox = c(-15, 35, 45, 65)) + tm_raster(&quot;elevation&quot;, palette = terrain.colors(8)) FIGURE 4.4: Global elevation data limited to the extent of the specified minimum and maximum coordinates. The second approach allows setting the map extent based on a search query. In the code below, we limit the map extent to the area of \"Europe\" (Figure 4.5). This approach uses the OpenStreetMap tool called Nominatim to automatically generate minimum and maximum coordinates in the x and y directions based on the provided query. tm_shape(land, bbox = &quot;Europe&quot;) + tm_raster(&quot;elevation&quot;, palette = terrain.colors(8)) FIGURE 4.5: Global elevation data limited to the extent specified with the ‘Europe’ query. In the last approach, the map extent is based on another existing spatial object. Figure 4.6 shows the elevation raster data (land) limited to the edge coordinates from metro_large. tm_shape(land, bbox = metro_large) + tm_raster(&quot;elevation&quot;, palette = terrain.colors(8)) FIGURE 4.6: Global elevation data limited to the extent of the other spatial object. 4.5 Data simplification Geometries in spatial vector data consists of sets of coordinates (Section 2.2.1). Spatial vector objects grow larger with more features to present and more details to show, and this also has an impact on time to render a map. Figure 4.7:A shows a map of countries from the World object. tm_shape(World) + tm_polygons() This level of detail can be good for some maps, but sometimes the number of details can make reading the map harder. To show a simplified (smoother) version of vector data, we can use the simplify argument of tm_shape()8. It expects a numeric value from 0 to 1 - a proportion of vertices in the data to retain. In the example below, we set simplify to 0.05, which keeps 5% of vertices (Figure 4.7:B). tm_shape(World, simplify = 0.05) + tm_polygons() The process of simplification can also be more controlled. By default, the underlining algorithm (called the Visvalingam method, learn more at https://bost.ocks.org/mike/simplify/), removes small features, such as islands in our case. This could have far-reaching consequences - in the process of simplification, we can remove some countries! To prevent the deletion of small features, we also need to set keep.units to TRUE. tm_shape(World, simplify = 0.05, keep.units = TRUE) + tm_polygons() Figure 4.7:C shows the result of such an operation. Now, our map contains all of the countries from the original data, but in a simplified form. keep.units = TRUE, however, does not keep all of the subfeatures. In the case of one country consisting of many small polygons, only one is sure to be retained. For example, look at New Zealand, which is now only represented by Te Waipounamu (the South Island). To keep all of the spatial geometries (even the smallest of islands), we should also specify keep.subunits to TRUE. tm_shape(World, simplify = 0.05, keep.units = TRUE, keep.subunits = TRUE) + tm_polygons() Figure 4.7:D contains a simplified map, where each spatial geometry of the original map still exists, but in a less detailed form. #&gt; Warning: rmapshaper package is needed to simplify #&gt; the shape. Alternatively, st_simplify from the sf #&gt; package can be used. See the underlying function #&gt; tmaptools::simplify_shape for details. #&gt; Warning: rmapshaper package is needed to simplify #&gt; the shape. Alternatively, st_simplify from the sf #&gt; package can be used. See the underlying function #&gt; tmaptools::simplify_shape for details. #&gt; Warning: rmapshaper package is needed to simplify #&gt; the shape. Alternatively, st_simplify from the sf #&gt; package can be used. See the underlying function #&gt; tmaptools::simplify_shape for details. #&gt; Warning: rmapshaper package is needed to simplify #&gt; the shape. Alternatively, st_simplify from the sf #&gt; package can be used. See the underlying function #&gt; tmaptools::simplify_shape for details. #&gt; Warning: rmapshaper package is needed to simplify #&gt; the shape. Alternatively, st_simplify from the sf #&gt; package can be used. See the underlying function #&gt; tmaptools::simplify_shape for details. #&gt; Warning: rmapshaper package is needed to simplify #&gt; the shape. Alternatively, st_simplify from the sf #&gt; package can be used. See the underlying function #&gt; tmaptools::simplify_shape for details. FIGURE 4.7: A map of world’s countries based on: (A) original data, (B) simplified data with 5% of vertices kept, (C) simplified data with 5% of vertices, and all features kept, (D) simplified data with 5% of vertices, all features, and all polygons kept. All of the about vector simplification functions use the ms_simplify() from the rmapshaper package . Therefore, you can customize the data simplification even further using other arguments of ms_simplify() (except for the arguments input, keep, keep_shapes, and explode). Raster data is represented by a grid of cells (Section 2.2.2), and the number of cells impacts the time to render a map. Rasters with hundreds of cells will be plotted quickly, while rasters with hundreds of millions or billions of cells will take a lot of time (and RAM) to be shown. Therefore, the tmap package downsamples large rasters by default to be below 10,000,000 cells in the plot mode and 1,000,000 cells in the view mode. This values can be adjusted with the max.raster argument of tmap_options(), which expects a named vector with two elements - plot and view. (Figure 4.8:A). tmap_options(max.raster = c(plot = 5000, view = 2000)) tm_shape(land) + tm_raster(&quot;elevation&quot;) Raster downsampling can be also disabled with the raster.downsample argument of tm_shape() (Figure 4.8:B). tm_shape(land, raster.downsample = FALSE) + tm_raster(&quot;elevation&quot;) FIGURE 4.8: (A) A raster map with the decreased resolution, (B) a raster map in the original resolution. Any tmap options can be reset (set to default) with tmap_options_reset() (We explain tmap_options() in details in Chapter 11). tmap_options_reset() References "],["layers.html", "Chapter 5 Layers 5.1 Polygons 5.2 Symbols 5.3 Lines 5.4 Text 5.5 Raster 5.6 Tile 5.7 Combining layers", " Chapter 5 Layers 5.1 TABLE 5.1: Map layers. Function Element Geometry Basic functions tm_polygons() polygons (borders and fill) polygons tm_symbols() symbols points, polygons, and lines tm_lines() lines lines tm_raster() raster raster tm_text() text points, polygons, and lines tm_basemap() tile tm_tiles() tile Derived functions tm_borders() polygons (borders) polygons tm_fill() polygons (fill) polygons tm_bubbles() bubbles points, polygons, and lines tm_dots() dots points, polygons, and lines tm_markers() marker symbols points, polygons, and lines tm_square() squares points, polygons, and lines tm_iso() lines with text labels lines tm_rgb()/tm_rgba() raster (RGB image) raster In this chapter, we focus on what map layers are available in tmap and how they differ. Chapter 6, on the other hand, is all about how to present information given in variables using colors, sizes, and shapes. 5.1 Polygons library(tmap) library(sf) ei_borders = read_sf(&quot;data/easter_island/ei_border.gpkg&quot;) The main function to visualize polygons is tm_polygons(). By default, it plots areas of polygons in light gray (gray85) and polygons borders in slightly dark gray (gray40). tm_shape(ei_borders) + tm_polygons() Both, colors of areas (polygons’ fillings) and colors of borders can be modified using the col and border.col arguments (Figure 5.1:A). tm_shape(ei_borders) + tm_polygons(col = &quot;lightblue&quot;, border.col = &quot;black&quot;, lwd = 0.5, lty = &quot;dashed&quot;) In fact, tm_polygons() is a combination of two separate functions - tm_fill() and tm_borders(). The tm_fill() function fills polygons with a fixed color or a color palette representing a selected variable (Figure 5.1:B). tm_shape(ei_borders) + tm_fill(col = &quot;lightblue&quot;) The tm_borders() function draws the borders of the polygons only (Figure 5.1:C). It allows to change the colors of borders, their widths, or the lines type. tm_shape(ei_borders) + tm_borders(col = &quot;black&quot;, lwd = 0.5, lty = &quot;dashed&quot;) Notice that we have used the col argument in tm_borders(), but border.col in tm_polygons(). This is necessary to distinguish between the setting of the fillings color and the borders’ color. FIGURE 5.1: Example of a map created with: (A) ‘tm_polygons()’ , (B) ‘tm_fill()’ , (C) ‘tm_borders()’ . More information on colors, and how they can be applied and modified is explained in detail in Chapter 6.1. 5.2 Symbols ei_points = read_sf(&quot;data/easter_island/ei_points.gpkg&quot;) volcanos = subset(ei_points, type == &quot;volcano&quot;) Symbols are a very flexible layer type. They are usually used to represent point data, but can be also used for lines and polygons. In the latter cases, they are located in centroid coordinates of each feature. Their flexibility is also related to the ways symbols can be visualized - it is possible to show values of a given variable by colors of symbols, their sizes, or shapes (more about that is explained in Chapter 6. The tm_symbols() is the main function in tmap allowing to use and modify symbol elements (Figure 5.2). By default, this function draws a gray circle symbol with a black border for each element of an input feature. FIGURE 5.2: A map showing the default tmap symbols. In the above example, each symbol is related to one feature (row) in the metro2 object. However, in a case when we provide multi-element features (such as MULTIPOINT; section 2.2.1), each multi-element object is first split into a number of single-element features and then plotted. The tm_symbols() is a very flexible function with a large number of arguments. While this allows adjusting its results to almost any need, it also makes this function complicated. Therefore, four additional layers are implemented in tmap: tm_squares(), tm_bubbles(), tm_dots(), tm_markers(). All of them use tm_symbols(), but with different default values. tm_squares() uses square symbols (shape = 22) instead of circles (shapes = 21) (Figure 5.3:A). tm_shape(volcanos) + tm_squares() (Figure 5.3:B) tm_shape(volcanos) + tm_bubbles() The main role of tm_dots() is to present many locations at the same time. To do this, this layer has a small size value (0.02) at the default (Figure 5.3:C). tm_shape(volcanos) + tm_dots() The last additional layer is tm_markers(), which uses a marker icon by default (Figure 5.3:D). tm_shape(volcanos) + tm_markers() FIGURE 5.3: Maps showing default visualizations using: (A) tm_squares(), (B) tm_bubbles(), (C) tm_dots(), (D) tm_markers(). 5.3 Lines ei_roads = read_sf(&quot;data/easter_island/ei_roads.gpkg&quot;) The tm_lines() function allows to visualize different types of line data (Figure 5.4). tm_shape(ei_roads) + tm_lines() FIGURE 5.4: Example of a map created with tm_lines. Lines can be presented using different colors, widths, or types (Chapter 6). This allows to show a hierarchy (for example, increased line widths for higher capacity roads) or distinguish between types of objects (for example, blue rivers comparing to gray roads). 5.4 Text Text labels are often an integral part of many maps. They can serve several functions, from naming features, indicating relations between them, or representing a given variable’s values. The main function to create text labels is tm_text(), which adds a label to each spatial feature (Figure 5.5). tm_shape(volcanos) + tm_text(text = &quot;name&quot;, size = &quot;elevation&quot;) + tm_layout(legend.outside = TRUE) FIGURE 5.5: Example of a map created with tm_text. We can adjust colors (col) and sizes (size; Section 6.2) of labels either by providing a single value or a name of a data variable. Text labels can be modified with a set of unique arguments, including case (\"upper\" or \"lower\"), shadow (TRUE or FALSE), fontface and fontfamily. Text labels can be added to spatial (multi-)points, (multi-)lines, and (multi-)polygons, and each of the cases is quite different. The simplest case is for POINT data, for which each text label will be located precisely in coordinates of the given points (Figure 5.5). However, how to add text labels to multipoints, lines, multilines, polygons, or multipolygons? Should each label correspond to one spatial feature, or should every sub-feature have their own label? Where should the labels be placed for lines or polygons - in the center of a line and centroid of a polygon or somewhat different? # x2 = x %&gt;% # dplyr::group_by(region_un) %&gt;% # dplyr::summarise() # tm_shape(x2) + # tm_polygons() + # tm_text(&quot;region_un&quot;) Text labels are also often presented together with lines (Section 5.3). One example is an isopleth - a line drawn on a map through all points having the same value of a given variable, such as atmospheric pressure or elevation. Isopleths can be created with the tm_iso() function. data(land, package = &quot;tmap&quot;) # library(raster) # elev = land[&quot;elevation&quot;] # elev_isopleths = rasterToContour(as(elev, &quot;Raster&quot;)) # think about tm_iso example # improve example # tm_shape(elev_isopleths) + # tm_iso() # # library(tmap) # data(&quot;dem&quot;, package = &quot;spDataLarge&quot;) # # create hillshade # hs = hillShade(slope = terrain(dem, &quot;slope&quot;), aspect = terrain(dem, &quot;aspect&quot;)) # # create contour # cn = rasterToContour(dem) # # tm_shape(hs) + # tm_grid() + # tm_raster(palette = gray(0:100 / 100), n = 100, legend.show = FALSE) + # tm_shape(dem) + # tm_raster(alpha = 0.5, palette = terrain.colors(25), # legend.show = FALSE) + # tm_shape(cn) + # tm_lines(col = &quot;white&quot;) + # tm_text(&quot;level&quot;, col = &quot;white&quot;) 5.5 Raster library(stars) #&gt; Loading required package: abind ei_elev = read_stars(&quot;data/easter_island/ei_elev.tif&quot;) ei_geomorphons = read_stars(&quot;data/easter_island/ei_geomorphons.tif&quot;) Visualization of raster data depends on the raster type (continuous or categorical), its resolution, and the number of layers. Figure 4.8 shows two simple example of continuous and categorical raster visualization created with tm_raster(). This function attempts to recognize the type of a given raster - when the input raster is continuous then the pretty style is used. However, the \"cont\" style often better represent phenomena that progressively vary in space (Figure 5.6:A). tm_shape(ei_elev) + tm_raster(title = &quot;Elevation (m asl):&quot;, style = &quot;cont&quot;, palette = &quot;viridis&quot;) On the other hand, when the given raster is categorical, then tm_raster uses style = \"cat\" (Figure 5.6:A). We can also adjust the legend title, used colors, and many more, in a similar fashion as in the previously mentioned layers. labels = c(&quot;flat&quot;, &quot;summit&quot;, &quot;ridge&quot;, &quot;shoulder&quot;, &quot;spur&quot;, &quot;slope&quot;, &quot;hollow&quot;, &quot;footslope&quot;, &quot;valley&quot;, &quot;depression&quot;) colors = c(&quot;#dcdcdc&quot;, &quot;#380000&quot;, &quot;#c80000&quot;, &quot;#ff5014&quot;, &quot;#fad23c&quot;, &quot;#ffff3c&quot;, &quot;#b4e614&quot;, &quot;#3cfa96&quot;, &quot;#0000ff&quot;, &quot;#000038&quot;) tm_shape(ei_geomorphons) + tm_raster(title = &quot;Geomorphons:&quot;, style = &quot;cat&quot;, palette = colors, labels = labels) #&gt; stars object downsampled to 1194 by 837 cells. See tm_shape manual (argument raster.downsample) #&gt; stars object downsampled to 1194 by 837 cells. See tm_shape manual (argument raster.downsample) FIGURE 5.6: Examples of (A) continuous raster maps, and (B) categorical raster maps. The above examples used a raster with one layer only. However, rasters can have many layers, either represented by dimensions or attributes. By default, tmap shows all of the layers, where each raster has its own legend. tm_shape(land) + tm_raster() We can modify their arrangement with tm_facets() and (Figure 5.7). tm_shape(land) + tm_raster() + tm_facets(nrow = 1) + tm_layout(panel.labels = c(&quot;Land cover&quot;, &quot;Land cover (simpl.)&quot;, &quot;Percent Tree Cover&quot;, &quot;Elevation&quot;)) FIGURE 5.7: A map created from a multilayered raster. We focus on how to specify and modify facets (also known as small multiples) in Chapter 10 and how to modify map layout in Chapter 8. #to replace later library(stars) landsat = read_stars(system.file(&quot;raster/landsat.tif&quot;, package = &quot;spDataLarge&quot;)) The landsat object contains four bands (blue, green, red, and near-infrared) of the Landsat 8 image for the area of Zion National Park taken on 18th of August 2015. We can plot all of the bands independently or as a combination of three bands. This combination is known as a color composite image, and we can create such images with the tm_rgb() function (Figure 5.8). Standard composite image (true color composite) uses the visible red, green, and blue bands to represent the data in natural colors. We can specify which band in landsat relates to red (third band), green (second band), and blue (first band) color in tm_rgb. Also, by default, this function expects values from 0 to 255; however, our values are in a different scale, with the maximum value of 31961. Therefore, to create a map, we can set max.value to our dataset’s maximum value. The result is a true color composite, with green colors representing forests and other types of vegetation, and yellow color showing bare areas (Figure 5.8:A). tm_shape(landsat) + tm_rgb(r = 3, g = 2, b = 1, max.value = 31961) True color images are straightforward to interpret and understand, but they make subtle differences in features challenging to recognize. However, nothing stops us from using the above tools to integrate different bands to create so called false color composites. Various band combinations emphasize some spatial characteristics, such as water, agriculture, etc., and allows us to visualize wavelengths that our eyes can not see. Figure 5.8:B shows a composite of near-infrared, red, and green bands, highlighting vegetation with a bright red color. tm_shape(landsat) + tm_rgb(r = 4, g = 3, b = 2, max.value = 31961) FIGURE 5.8: Two color composite images: (A) true color composite, (B) false color composite. 5.6 Tile data(metro) Tile layers can be used for two purposes: either as a basemap or an overlay layer. By default, three basemaps are available in the interactive mode (tmap_mode(\"view\")): \"Esri.WorldGrayCanvas\", \"OpenStreetMap\", and \"Esri.WorldTopoMap\". However, we can change the used basemaps with a vector with the names of the tile layers’ providers (Figure 5.9). tmap_mode(&quot;view&quot;) tm_basemap(c(TopoMap = &quot;OpenTopoMap&quot;, StreetMap = &quot;OpenStreetMap&quot;)) + tm_shape(volcanos, is.master = TRUE) + tm_dots(col = &quot;red&quot;, group = &quot;Volcanos&quot;) FIGURE 5.9: Topographic tile layer used as a base map with the red dots representing major metropolitan areas in India In the above code, we made two basemaps available - \"OpenTopoMap\", and \"OpenStreetMap\", and for the map legend purpose, we renamed them as TopoMap and StreetMap. A complete list of available basemaps is in the leaflet::providers object and on the https://leaflet-extras.github.io/leaflet-providers/preview/ website9. The tm_basemap(NULL) function allows to disable basemaps entirely. The tm_tiles() function, on the other hand, draws the tile layer on the top (as overlay layer) of the previous tm_ layer. In the next example, we put the vector \"OpenRailwayMap\" tiles on top of the previously set basemaps, but below the following dots layer (Figure 5.10). tm_basemap(c(TopoMap = &quot;OpenTopoMap&quot;, StreetMap = &quot;OpenStreetMap&quot;)) + tm_tiles(c(TonerHybrid = &quot;Stamen.TonerHybrid&quot;)) + tm_shape(volcanos, is.master = TRUE) + tm_dots(col = &quot;red&quot;, group = &quot;Volcanos&quot;) FIGURE 5.10: Topographic tile layer used as a base map with orange lines representing railways and the red dots representing major metropolitan areas in India library(maptiles) ei_tiles = get_tiles(ei_borders, crop = TRUE, zoom = 12, provider = &quot;Stamen.Toner&quot;) get_credit(&quot;Stamen.Toner&quot;) tmap_mode(&quot;plot&quot;) tm_shape(ei_tiles) + tm_rgb() + tm_shape(ei_borders) + tm_borders(lwd = 5, col = &quot;lightblue&quot;) + tm_scale_bar(breaks = c(0, 2, 4), bg.color = &quot;white&quot;) + tm_credits(get_credit(&quot;Stamen.Toner&quot;), bg.color = &quot;white&quot;) 5.7 Combining layers # tm_shape(x) + # tm_polygons(col = &quot;gdpPercap&quot;) + # tm_symbols(col = &quot;lifeExp&quot;, palette = &quot;viridis&quot;, size = 0.2) Additional details can be found in the leaflet::providers.details object↩︎ "],["visual-variables.html", "Chapter 6 Visual variables 6.1 Colors 6.2 Sizes 6.3 Shapes 6.4 Mixing visual variables", " Chapter 6 Visual variables Visual variables are methods to translate information given in variables into many types of visualizations, including maps. Basic visual variables are color, size, and shape10. All of them can influence our perception and understanding of the presented information, therefore it is worth to understand when and how they can be used. FIGURE 6.1: Basic visual variables and their representations on maps The use of visual variables on maps depends on two main things: (a) type of the presented variable, and (b) type of the map layer. Figure 6.1 shows examples of different visual variables. Color is the most universal visual variable. It can represent both qualitative (categorical) and quantitative (numerical) variables, and also we can color symbols, lines, or polygon fillings (sections 6.1.1 and 6.1.2). Sizes, on the other hand, should focus on quantitative variables. Small symbols could represent low values of a given variable, and the higher the value, the larger the symbol. Quantitative values of line data can be shown with the widths of the lines (section 6.2). The use of shapes usually should be limited to qualitative variables, and different shapes can represent different categories of points (section 6.3). Similarly, qualitative variables in lines can be presented by different line types. Values of polygons usually cannot be represented by either shapes or sizes, as these two features are connected to the geometries of the objects. 6.1 Colors Colors, along with sizes and shapes, are the most often used to express values of attributes or their properties. Proper use of colors draws the attention of viewers and has a positive impact on the clarity of the presented information. On the other hand, poor decisions about colors can lead to misinterpretation of the map. Section 6.1.1 explains how colors are represented in R, how to decide which colors to use, and how to set different colors on maps. Section 6.1.2 focuses on how to specify color breaks and which types of scales styles are appropriate in different cases. 6.1.1 Color palettes Colors in R are created based either on the color name or its hexadecimal form. R understands 657 built-in color names, such as \"red\", \"lightblue\" or \"gray90\", that are available using the colors() function. Hexadecimal form, on the other hand, can represent 16,777,216 unique colors. It consists of six-digits prefixed by the # (hash) symbol, where red, green, and blue values are each represented by two characters. In hexadecimal form, 00 is interpreted as 0.0 which means a lack of a particular color and FF means 1.0 and shows that the given color has maximal intensity. For example, #000000 represents black color, #FFFFFF white color, and #00FF00 green color. Using a single color we are able to draw points, lines, polygon borders, or their areas. In that scenario, all of the elements will have the same color. However, often we want to represent different values in our data using different colors. This is a role for color palettes. A color palette is a set of colors used to distinguish the values of variables on maps. Color palettes in R are usually stored as a vector of either color names or hexadecimal representations. For example, c(\"red\", \"green\", \"blue\") or c(\"#66C2A5\", \"#FC8D62\", \"#8DA0CB\"). It allows every one of us to create our own color palettes. However, the decision on how to decide which colors to use is not straightforward, and usually requires thinking about several aspects. Firstly, what kind of variable we want to show? Is it a categorical variable where each value represents a group or a numerical variable in which values have order? The variable type impacts how it should be presented on the map. For categorical variables, each color usually should receive the same perceptual weight, which is done by using colors with the same brightness, but different hue. On the other hand, for numerical variables, we should easily understand which colors represent lower and which represent higher values. This is done by manipulating colorfulness and brightness. For example, low values could be presented by a blue color with low colorfulness and high brightness, and with growing values, colorfulness increases and brightness decreases. Next consideration is related to how people perceive some colors. Usually, we want them to be able to preliminary understand which values the colors represent without looking at the legend – colors should be intuitive. For example, in the case of categorical variables representing land use, we usually want to use some type of blue color for rivers, green for trees, and white for ice. This idea also extends to numerical variables, where we should think about the association between colors and cultural values. The blue color is usually connected to cold temperature, while the red color is hot or can represent danger or something not good. However, we need to be aware that the connection between colors and cultural values varied between cultures. Another thing to consider is to use a color palette that is accessible for people with color vision deficiencies (color blindness). There are several types of color blindness, with the red-green color blindness (deuteranomaly) being the most common. It is estimated that up to about 8% of the male population and about 0.5% of the female population in some regions of the world is color blind (Birch 2012; Sharpe et al. 1999). The relation between the selected color palette and other map elements or the map background should be also taken into a consideration. For example, using a bright or dark background color on a map has an impact on how people will perceive different color palettes. Generally, color palettes can be divided into three main types (Figure 6.2): Categorical (also known as Qualitative) - used for presenting categorical information, for example, categories or groups. Every color in this type of palettes should receive the same perceptual weight, and the order of colors is meaningless. Categorical color palettes are usually limited to dozen or so different colors, as our eyes have problems with distinguishing a large number of different hues. Their use includes, for example, regions of the world or land cover categories. Sequential - used for presenting continuous variables, in which order matters. Colors in this palette type changes from low to high (or vice versa), which is usually underlined by luminance differences (light-dark contrasts). Sequential palettes can be found in maps of GDP, population density, elevation, and many others. Diverging - used for presenting continuous variables, but where colors diverge from a central neutral value to two extremes. Therefore, in sense, they consist of two sequential palettes that meet in the midpoint value. Examples of diverging palettes include maps where a certain temperature or median value of household income is use as the midpoint. It can also be used on maps to represent difference or change as well. FIGURE 6.2: Examples of three main types of color palettes: categorical, sequential, and diverging Gladly, a lot of work has been put on creating color palettes that are grounded in the research of perception and design. Currently, several dozens of R packages contain hundreds of color palettes. The most popular among them are RColorBrewer (Neuwirth 2014) and viridis (Garnier 2018). RColorBrewer builds upon a set of perceptually ordered color palettes (Harrower and Brewer 2003) and the associated website at https://colorbrewer2.org. The website not only presents all of the available color palettes, but also allow to filter them based on their properties, such as being colorblind safe or print-friendly. The viridis package has five color palettes are perceptually-uniform and suitable for people with color blindness. Four palettes is this package (“viridis”, “magma”, “plasma”, and “inferno”) are derived from the work on the color palettes for the matplotlib Python library. The last one, “cividis”, is based on the work of Nuñez, Anderton, and Renslow (2018). RColorBrewer::brewer.pal(7, &quot;RdBu&quot;) #&gt; [1] &quot;#B2182B&quot; &quot;#EF8A62&quot; &quot;#FDDBC7&quot; &quot;#F7F7F7&quot; &quot;#D1E5F0&quot; #&gt; [6] &quot;#67A9CF&quot; &quot;#2166AC&quot; viridis::viridis(7) #&gt; [1] &quot;#440154FF&quot; &quot;#443A83FF&quot; &quot;#31688EFF&quot; &quot;#21908CFF&quot; #&gt; [5] &quot;#35B779FF&quot; &quot;#8FD744FF&quot; &quot;#FDE725FF&quot; In the last few years, the grDevices package that is an internal part of R, have received several improvements over color palette handling.11 It includes creation of hcl.colors() and palette.colors(). The hcl.colors() function incorporates color palettes from several R packages, including RColorBrewer, viridis, rcartocolor (CARTO 2019; Nowosad 2018), and scico (Crameri 2018; Pedersen and Crameri 2020). You can get the list of available palette names for hcl.colors() using the hcl.pals() function and visualize all of the palettes with colorspace::hcl_palettes(plot = TRUE). The palette.colors() function adds several palettes for categorical data. It includes \"Okabe-Ito\" suited for color vision deficiencies or \"Polychrome 36\" that has 36 unique colors (Coombes et al. 2019). You can find the available names of the palettes for this function using palette.pals() grDevices::hcl.colors(7, &quot;Oslo&quot;) #&gt; [1] &quot;#FCFCFC&quot; &quot;#C2CEE8&quot; &quot;#86A2D3&quot; &quot;#3C79C0&quot; &quot;#275182&quot; #&gt; [6] &quot;#132B48&quot; &quot;#040404&quot; grDevices::palette.colors(7, &quot;Okabe-Ito&quot;) #&gt; black orange skyblue bluishgreen #&gt; &quot;#000000&quot; &quot;#E69F00&quot; &quot;#56B4E9&quot; &quot;#009E73&quot; #&gt; yellow blue vermillion #&gt; &quot;#F0E442&quot; &quot;#0072B2&quot; &quot;#D55E00&quot; One of the most widely used color palettes is “rainbow” (the rainbow() function in R). It was inspired by colors of rainbows - a set of seven colors going from red to violet. However, this palette has a number of disadvantages, including irregular changes in brightness affecting its interpretation or being unsuitable for people with color vision deficiencies (Borland and Taylor Ii 2007; Stauffer et al. 2015; Quinan et al. 2019). Depending on a given situation, there are many palettes better suited for visualization than “rainbow”, including sequential \"viridis\" and \"ag_Sunset\" or diverging \"Purple-Green\" and \"Fall\". All of them can be created with the grDevices::hcl.colors() function. More examples showing alternatives to the “rainbow” palette are in the documentation of the colorspace package at https://colorspace.r-forge.r-project.org/articles/endrainbow.html (Zeileis et al. 2019). By default, the tmap package attempts to identify the type of the used variable. Based on the result, it selects one of the build-in palettes: categorical \"Set3\", sequential \"YlOrBr\", or diverging \"RdYlGn\" (Figure 6.3). tm_shape(x) + tm_polygons(&quot;lifeExp&quot;) It also offers three main ways to specify color palettes using the palette argument: (1) a vector of colors, (2) a palette function, or (3) one of the build-in names (Figure 6.3). A vector of colors can be specified using color names or hexadecimal representations (Figure 6.3). Importantly, the length of the provided vector does not need to be equal to the number of colors in the map legend. tmap automatically interpolates new colors in the case when a smaller number of colors is provided. tm_shape(x) + tm_polygons(&quot;lifeExp&quot;, palette = c(&quot;yellow&quot;, &quot;darkgreen&quot;)) Another approach is to provide the output of a palette function (Figure 6.3). In the example below, we derived seven colors from \"ag_GrnYl\" palette. This palette goes from green colors to yellow ones, however, we wanted to reverse the order of this palette. Thus, we also used the rev() function here. tm_shape(x) + tm_polygons(&quot;lifeExp&quot;, palette = rev(hcl.colors(7, &quot;ag_GrnYl&quot;))) The last approach is to use one of the names of color palettes build-in in tmap (Figure 6.3). In this example, we used the \"YlGn\" palette that goes from yellow to green. tm_shape(x) + tm_polygons(&quot;lifeExp&quot;, palette = &quot;YlGn&quot;) You can find all of the named color palettes using an interactive app with tmaptools::palette_explorer(). It is also possible to reverse the order of any named color palette by using the - prefix. Therefore, \"-YlGn\" will return a palette going from green to yellow. FIGURE 6.3: Examples of four ways of specifying color palettes: (A) default sequential color palette, (B) palette created based on provided vector of colors, (C) palette created using the hcl.colors function, and (D) one of the build-in palettes. The default color palette for positive numerical variables is \"YlOrBr\" as seen in Figure 6.4:A. On the other hand, when the given variable has both negative and positive values, then tmap uses the \"RdYlGn\" color palette, with red colors below the midpoint value, yellow color around the midpoint value, and green colors above the midpoint value. The use of diverging color palettes can be adjusted using the midpoint argument. It has a value of 0 as the default, however, it is possible to change it to any other value. For example, we want to create a map that shows countries with life expectancy below and above the median life expectancy of about 73 years. To do that, we just need to set the midpoint argument to this value (Figure 6.4:B). tm_shape(x) + tm_polygons(col = &quot;lifeExp&quot;, midpoint = 73) FIGURE 6.4: Examples of (A) a map with the default sequential color palette and (B) a map with the diverging color palette around the midpoint value of 73. Now the countries with low life expectancy are presented with red colors, yellow areas represent countries with life expectancy around the median value (the midpoint in our case), and the countries with high life expectancy are represented by green colors. The above examples all contain several polygons with missing values of a given variable. Objects with missing values are, by default, represented by gray color and a related legend label Missing. However, it is possible to change this color with the colorNA argument and its label with textNA. tmap has a special way to set colors for categorical maps manually. It works by providing a named vector to the palette argument. In this vector, names of the categories from the categorical variable are the vector names, and specified colors are the vector values. You can see it in the example below, where we plot the \"region_un\" categorical variable (Figure 6.5). Each category in this variable (e.g., \"Africa\") has a new, connected to it color (e.g., \"#11467b\"). tm_shape(x) + tm_polygons(&quot;region_un&quot;, palette = c( &quot;Africa&quot; = &quot;#11467b&quot;, &quot;Americas&quot; = &quot;#ffd14d&quot;, &quot;Antarctica&quot; = &quot;#86909a&quot;, &quot;Asia&quot; = &quot;#14909a&quot;, &quot;Europe&quot; = &quot;#7fbee9&quot;, &quot;Oceania&quot; = &quot;#df5454&quot;, &quot;Seven seas (open ocean)&quot; = &quot;#7b1072&quot;) ) #&gt; Some legend labels were too wide. These labels have been resized to 0.64. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. FIGURE 6.5: An example of a categorical map with manually selected colors Finally, visualized colors can be additionally modified. It includes setting the alpha argument that represents the transparency of the used colors. By default, the colors are not transparent at all as the value of alpha is 1. However, we can decrease this value to 0 - total transparency. The alpha argument is useful in two ways: one - it allows us to see-through some large objects (e.g., some points below the polygons or a hillshade map behind the colored raster of elevation), second - it makes colors more subtle. 6.1.2 Color scale styles tm_polygons() accepts three ways of specifying the fill color with the col argument12. The first one is to fill all polygons with the same color. This happens when we provide a single color value, either as a color name or its hexadecimal form (section 6.1.1) (Figure 6.6). tm_shape(x) + tm_polygons(col = &quot;lightblue&quot;) FIGURE 6.6: Example of a map with all polygons filled with the same color. The second way of specifying the fill color is to provide a name of the column (variable) we want to visualize. tmap behaves differently depending on the input variable type, but always automatically adds a map legend. In general, a categorical map is created when the provided variable contains characters, factors, or is of the logical type. However, when the provided variable is numerical, then it is possible to create either a discrete or a continuous map. An example of a categorical map can be seen in Figure 6.7. We created it by providing a character variable’s name, \"region_un\", in the col argument13. tm_shape(x) + tm_polygons(col = &quot;region_un&quot;) FIGURE 6.7: Example of a map in which polygons are colored based on the values of a categorical variable. It is possible to change the names of legend labels with the labels argument. However, to change the order of legend labels, we need to provide an ordered factor variable’s name instead of a character one. As mentioned in the section 6.1.1, we can also change the used color palette with the palette argument. Discrete maps, on the other hand, represent continuous numerical variables using discrete class intervals. In other words, values are divided into several groups based on their properties. Several approaches can be used to convert continuous variables to discrete ones, and each of them could result in different groups of values. tmap has 14 different methods to create discrete maps that can be specified with the style argument. Most of them (except \"log10_pretty\") use the classInt package (Bivand 2020) in the background, therefore some additional information can be found in the ?classIntervals function’s documentation. By default, the \"pretty\" style is used (Figure 6.8:A). This style creates breaks that are whole numbers and spaces them evenly.14 tm_shape(x) + tm_polygons(col = &quot;gdpPercap&quot;) It is also possible to indicate the desired number of classes using the n argument, when the \"pretty\" style is used. While not every n is possible depending on the input values, tmap will try to create a number of classes as close to possible to the preferred one. The next approach is to manually select the limits of each break with the breaks function (Figure 6.8:B). This can be useful when we have some pre-defined breaks, or when we want to compare values between several maps. It expects threshold values for each break, therefore, if we want to have three breaks, we need to provide four thresholds. Additionally, we can add a label to each break with the labels argument. tm_shape(x) + tm_polygons(col = &quot;gdpPercap&quot;, breaks = c(0, 10000, 30000, 121000), labels = c(&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;)) Another approach is to create breaks automatically using one of many existing classification methods. Three basic methods are \"equal\", \"sd\", and \"quantile\" styles. Let’s consider a variable with 100 observations ranging from 0 to 10. The \"equal\" style divides the range of values into n equal-sized intervals. This style works well when the values change fairly continuously and do not contain any outliers. In tmap, we can specify the number of classes with the n argument or the number of classes will be computed automatically . For example, when we set n to 4, then our breaks will represent four classes ranging from 0 to 2.5, 2.5 to 5, 5 to 7.5, and 7.5 to 10. The \"sd\" style represents how much values of a given variable varies from its mean, with each interval having a constant width of the standard deviation. This style is used when it is vital to show how values relate to the mean. The \"quantile\" style creates several classes with exactly the same number of objects (e.g., spatial features), but having intervals of various lengths. This method has an advantage or not having any empty classes or classes with too few or too many values. However, the resulting intervals from the \"quantile\" style can often be misleading, with very different values located in the same class. To create classes that, on the one hand, contain similar values, and on the other hand, are different from the other classes, we can use some optimization method. The most common optimization method used in cartography is the Jenks optimization method implemented at the \"jenks\" style (Figure 6.8:C). tm_shape(x) + tm_polygons(col = &quot;gdpPercap&quot;, style = &quot;jenks&quot;) The Fisher method (style = \"fisher\") has a similar role, which creates groups with maximized homogeneity (Fisher 1958). A different approach is used by the dpih style, which uses kernel density estimations to select the width of the intervals (Wand 1997). You can visit ?KernSmooth::dpih for more details. Another group of classification methods uses existing clustering methods. It includes k-means clustering (\"kmeans\"), bagged clustering (\"bclust\"), and hierarchical clustering (\"hclust\"). Finally, there are a few methods created to work well for a variable with a heavy-tailed distribution, including \"headtails\" and \"log10_pretty\". The \"headtails\" style is an implementation of the head/tail breaks method aimed at heavily right-skewed data. In it, values of the given variable are being divided around the mean into two parts, and the process continues iteratively for the values above the mean (the head) until the head part values are no longer heavy-tailed distributed (Jiang 2013). The \"log10_pretty\" style uses a logarithmic base-10 transformation (Figure 6.8:D). In this style, each class starts with a value ten times larger than the beginning of the previous class. In other words, each following class shows us the next order of magnitude. This style allows for a better distinction between low, medium, and high values. However, maps with logarithmically transformed variables are usually less intuitive for the readers and require more attention from them. tm_shape(x) + tm_polygons(col = &quot;gdpPercap&quot;, style = &quot;log10_pretty&quot;) FIGURE 6.8: Examples of four methods of creating discrete maps: (A) default method (‘pretty’), (B) the ‘fixed’ method with manually set breaks, (C) the ‘jenks’ method, and (D) the ‘log10_pretty’ method. Continuous maps also represent continuous numerical variables, but without any discrete class intervals (Figure 6.9). Three continuous methods exist in tmap: cont, order, and log10. Values change increasingly in all of them, but they differ in the relations between values and colors. The cont style creates a smooth, linear gradient. In other words, the change in values is proportionally related to the change in colors. We can see that in Figure 6.9:A, where the value change from 20,000 to 40,000 has a similar impact on the color scale as the value change from 40,000 to 60,000. The cont style is similar to the pretty one, where the values also change linearly. The main difference between these styles is that we can see differences between, for example, values of 45,000 and 55,000 in the former, while both values have exactly the same color in the later one. The cont style works well in situations where there is a large number of objects in vectors or a large number of cells in rasters, and where the values change continuously (do not have many outliers). tm_shape(x) + tm_polygons(col = &quot;gdpPercap&quot;, style = &quot;cont&quot;) However, when the presented variable is skewed or have some outliers, we can use either order or log10 style. The order style also uses a smooth gradient with a large number of colors, but the values on the legend do not change linearly (Figure 6.9:B). It is fairly analogous to the quantile style, with the values on a color scale that divides a dataset into several equal-sized groups. tm_shape(x) + tm_polygons(col = &quot;gdpPercap&quot;, style = &quot;order&quot;) Finally, the log10 style is the continuous equivalent of the log10_pretty style (Figure 6.9:C). tm_shape(x) + tm_polygons(col = &quot;gdpPercap&quot;, style = &quot;log10&quot;) FIGURE 6.9: Examples of three methods of creating continuous maps: (A) the ‘cont’ method, (B) the ‘order’ method, and (C) the ‘log10’ method. The tm_polygons() also offer a third way of specifying the fill color. When the col argument is set to \"MAP_COLORS\" then polygons will be colored in such a way that adjacent polygons do not get the same color (Figure 6.10). tm_shape(x) + tm_polygons(col = &quot;MAP_COLORS&quot;) In this case, it is also possible to change the default colors with the palette argument, but also to activate the internal algorithm to search for a minimal number of colors for visualization by setting minimize = TRUE. FIGURE 6.10: Example of a map with adjacent polygons having different colors. All of the color scale styles mentioned above work not only for tm_polygons() - they can be also applied for tm_symbols() (and its derivatives - tm_dots(), tm_bubbles(), tm_squares()), tm_lines(), tm_fill(), and tm_raster(). The col argument colors symbols’ fillings in tm_symbols(), lines in tm_lines(), and cells in tm_rasters(). 6.2 Sizes ei_points = read_sf(&quot;data/easter_island/ei_points.gpkg&quot;) volcanos = subset(ei_points, type == &quot;volcano&quot;) Differences in sizes between objects are relatively easy to recognize on maps. Sizes can be used for points, lines (line widths), or text to represent quantitative (numerical) variables, where small values are related to small objects and large values are presented by large objects. Large sizes can be also used to attract viewers’ attention. By default, tmaps present points, lines, or text objects of the same size. For example, tm_symbols() returns a map where each object is a circle with a consistent size15. We can change the sizes of all objects using the size argument (Figure 6.11:A). tm_shape(volcanos) + tm_symbols(size = 0.5) On the other hand, if we provide the name of the numerical variable in the size argument (e.g., \"pop2020\"), then symbol sizes are scaled proportionally to the provided values. Objects with small values will be represented by smaller circles, while larger values will be represented by larger circles (Figure 6.11:B). tm_shape(volcanos) + tm_symbols(size = &quot;elevation&quot;) We can adjust size legend breaks with sizes.legend and the corresponding labels with sizes.legend.labels (Figure 6.11:C). However, this only modifies the legend, not the related objects. tm_shape(volcanos) + tm_symbols(size = &quot;elevation&quot;, title.size = &quot;Elevation&quot;, sizes.legend = c(100, 600), sizes.legend.labels = c(&quot;low&quot;, &quot;high&quot;)) For example in the above code, we just show examples of how symbols with population of one million and 10 million looks like on the map. FIGURE 6.11: Examples of three approaches for changing sizes of symbols: (A) all symbols have a consistent size of 0.5, (B) sizes of symbols depends on the values of the pop2020 variable, (C) sizes of symbols have a manually created legend. Widths of the lines can represent values of numerical variables for line data similar to sizes of the symbols for point data. The lwd argument in tm_lines() creates thin lines for small values and thick lines for large values of the given variable (Figure 6.12). ei_roads = read_sf(&quot;data/easter_island/ei_roads.gpkg&quot;) tm_shape(ei_roads) + tm_lines(lwd = &quot;strokelwd&quot;) #&gt; Legend labels were too wide. Therefore, legend.text.size has been set to 0.59. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. FIGURE 6.12: Example of a map where lines’ widths represent values of the corresponding lines. In the above example, values of the \"strokelwd\" are divided into four groups and represented by four line widths. Lines’ thickness can be change using the scale argument, where the value of 1 is the default, and increasing this values increases lines’ thickness. Also, similarly to the last example of the tm_symbols above, it is possible to modify the lines width legend, by changing its title (title.lwd), categories (lwd.legend), and their names (lwd.legend.labels). Text labels have a role to name features on a map or just to highlight some of them. Usually, the size of text labels is consistent for the same spatial objects. However, text labels can be also used to represent the values of some numerical variables. Figure 6.13 shows an example, in which text labels show names of different metropolitan areas, while their sizes are related to the populations of the areas. This allows us to not only locate different metropolitan areas on a map but also differentiate between less populous areas (e.g., Seattle) and more populous ones (e.g., Tokyo). tm_shape(volcanos) + tm_text(text = &quot;name&quot;, size = &quot;elevation&quot;) + tm_layout(legend.outside = TRUE) FIGURE 6.13: Example of a map where text sizes represent populations of the given metropolitan areas. 6.3 Shapes Shapes allow representing different categories of point data. They can be very generic, e.g., circle or square, just to be able to differentiate between categories, but often we use symbols that we associate with different types of features. For example, we use the letter P for parking lots, I for information centers, an airplane symbol for airports, or a bus symbol for bus stops. To use different shapes, we should use the shape argument in the tm_symbols() function. It expects the name of the categorical variable. tm_shape(ei_points) + tm_symbols(shape = &quot;natural&quot;, title.shape = &quot;Type:&quot;, shapes.labels = c(&quot;Cave entrance&quot;, &quot;Peak&quot;, &quot;Volcano&quot;)) By default, tmap uses symbols of filled circle, square, diamond, point-up triangle, and point-down triangle16. However, it is also possible to customize used symbols, their title, and labels. Legend title related to shapes is modified with the title.shape argument, while their labels use the shapes.lables argument. Shapes can be specified with the shapes argument, that allows using one of three options. The first one is a numeric value that specifies the plotting character of the symbol17. A complete list of available symbols and their corresponding numbers is in the ?pch function’s documentation. tm_shape(ei_points) + tm_symbols(shape = &quot;name&quot;, shapes = c(0, 2, 5)) Second option is to use a grob object. # library(grid) # library(ggplotify) # library(ggplot2) # # p1 = as.grob(~barplot(1:10)) # p2 = as.grob(expression(plot(rnorm(10), yaxt = &quot;n&quot;, xaxt = &quot;n&quot;, ann = FALSE, bty = &quot;n&quot;))) # p3 = as.grob(function() plot(sin, yaxt = &quot;n&quot;, xaxt = &quot;n&quot;, ann = FALSE, bty = &quot;n&quot;)) # p4 = ggplotGrob(ggplot(data.frame(x = 1:10, y = 1:10), aes(x, y)) + geom_point() + theme_void()) # tm_shape(metro2) + # tm_symbols(shape = &quot;group&quot;, # shapes = list(p3, p3, p3)) tm_shape(ei_points) + tm_symbols(shape = &quot;group&quot;, shapes = my_icons) The last possibility is to use an icon specification created with the tmap_icons() function, that uses any png images. The tmap_icons() function accepts a vector of file paths or urls, and also allows setting the width and height of the icon. In our example, we have three distinct groups, therefore we need to create new icons based on three images - icon1.png, icon2.png, and icon3.png in this case. my_icons = tmap_icons(c(&quot;images/icon1.png&quot;, &quot;images/icon2.png&quot;, &quot;images/icon3.png&quot;)) Now, we can use the prepared icons in the shapes argument (Figure 6.14:D). tm_shape(ei_points) + tm_symbols(shape = &quot;type&quot;, shapes = my_icons, border.col = NULL) FIGURE 6.14: Examples of two maps with different symbols: (A) default symbols, (B) user-defined symbols, (C) grob objects, and (D) icons. 6.4 Mixing visual variables The values of a given variable can be expressed by different categorical or sequential colors in polygons. Lines can be also colored by one variable, but also widths of the lines can represent values of another quantitative variable. When we use symbols, then we are able to use colors for one qualitative or quantitative variable, sizes for a quantitative variable, and shapes for another qualitative variable. Therefore, it is possible to mix some visual variables for symbols and lines. This section shows only some possible examples of mixing visual variables. Figure 6.15:A shows symbols, which sizes are scales based on the pop2020 variable and they are colored using the values from pop1950. This can be set with the size and col arguments. tm_shape(ei_points) + tm_symbols(size = &quot;sv&quot;, col = &quot;elevation&quot;) We can also modify all of the visual variables using the additional arguments explained in the previous sections. For example, we can set the color style (style), color palette (palette), or specify shapes (shapes) (Figure 6.15:B). tm_shape(ei_points) + tm_symbols(col = &quot;elevation&quot;, style = &quot;cont&quot;, palette = &quot;Greens&quot;, shape = &quot;type&quot;, shapes = c(23, 24, 25)) When we use plot polygons, there is only one visual variable we can use - color. Therefore, changing of map legend’s title in functions like tm_polygons() or tm_fill() is done with the title argument. However, what to do when we have two or more visual variables in, for example, tm_symbols()? In these cases, we need to specify a corresponding suffix for each title argument. The color title is set with title.col, size title with title.size, and shape title with title.size (Figure 6.15:C). tm_shape(ei_points) + tm_symbols(size = &quot;elevation&quot;, title.size = &quot;Elevation:&quot;, shape = &quot;type&quot;, title.shape = &quot;Type:&quot;) FIGURE 6.15: Examples of maps using two visual variables at the same time: (A) size and color, (B) color and shape, (C) size and shape. For line data, we can present its qualitative and quantitative variables using colors and quantitative variables using sizes (line widths) (Figure 6.16). #&gt; Legend labels were too wide. Therefore, legend.text.size has been set to 0.59. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger. FIGURE 6.16: A map using two visual variables, color and size (line width), at the same time. References "],["othertypes.html", "Chapter 7 Other types", " Chapter 7 Other types "],["layout.html", "Chapter 8 Layout 8.1 Attributes layers 8.2 Layout element", " Chapter 8 Layout 8.1 Attributes layers 8.1 TABLE 8.1: Attribute layers. Function Description tm_grid() draws coordinate grid lines of the coordinate system of the main shape object tm_graticules() draws latitude and longitude graticules tm_scale_bar() adds a scale bar tm_compass() adds a compass rose tm_credits() adds a text annotation tm_logo() adds a logo tm_xlab() adds an x axis labels tm_ylab() adds an y axis labels tm_minimap() adds minimap in the view mode only 8.2 Layout element "],["interactive.html", "Chapter 9 Interactive settings", " Chapter 9 Interactive settings "],["multiples.html", "Chapter 10 Small multiples", " Chapter 10 Small multiples "],["options.html", "Chapter 11 tmap options", " Chapter 11 tmap options "],["save.html", "Chapter 12 Save maps", " Chapter 12 Save maps "],["animations.html", "Chapter 13 Animations", " Chapter 13 Animations "],["shiny.html", "Chapter 14 tmap in shiny", " Chapter 14 tmap in shiny "],["goodmaps.html", "Chapter 15 How to make good maps?", " Chapter 15 How to make good maps? "],["references.html", "References", " References "]]
